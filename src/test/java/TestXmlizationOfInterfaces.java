/*
 * This code has been automatically generated by testgen.
 * Do NOT edit or append.
 */

import aas_core.aas3_0.types.impl.*;
import aas_core.aas3_0.types.model.*;
import aas_core.aas3_0.xmlization.Xmlization;
import org.junit.jupiter.api.Test;
import javax.annotation.Generated;
import javax.xml.stream.*;
import java.io.IOException;
import java.io.StringReader;
import java.io.StringWriter;
import static org.junit.jupiter.api.Assertions.assertEquals;

@Generated("Generated by aas-test-gen")
public class TestXmlizationOfInterfaces {
        @Test
        public void testRoundTripIHasSemanticsFromRelationshipElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final RelationshipElement instance = CommonJsonization.loadMaximalRelationshipElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasSemantics anotherInstance = Xmlization.Deserialize.deserializeIHasSemantics(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasSemanticsFromRelationshipElement

        @Test
        public void testRoundTripIHasSemanticsFromAnnotatedRelationshipElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final AnnotatedRelationshipElement instance = CommonJsonization.loadMaximalAnnotatedRelationshipElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasSemantics anotherInstance = Xmlization.Deserialize.deserializeIHasSemantics(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasSemanticsFromAnnotatedRelationshipElement

        @Test
        public void testRoundTripIHasSemanticsFromBasicEventElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final BasicEventElement instance = CommonJsonization.loadMaximalBasicEventElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasSemantics anotherInstance = Xmlization.Deserialize.deserializeIHasSemantics(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasSemanticsFromBasicEventElement

        @Test
        public void testRoundTripIHasSemanticsFromBlob() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Blob instance = CommonJsonization.loadMaximalBlob();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasSemantics anotherInstance = Xmlization.Deserialize.deserializeIHasSemantics(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasSemanticsFromBlob

        @Test
        public void testRoundTripIHasSemanticsFromCapability() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Capability instance = CommonJsonization.loadMaximalCapability();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasSemantics anotherInstance = Xmlization.Deserialize.deserializeIHasSemantics(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasSemanticsFromCapability

        @Test
        public void testRoundTripIHasSemanticsFromEntity() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Entity instance = CommonJsonization.loadMaximalEntity();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasSemantics anotherInstance = Xmlization.Deserialize.deserializeIHasSemantics(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasSemanticsFromEntity

        @Test
        public void testRoundTripIHasSemanticsFromFile() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final File instance = CommonJsonization.loadMaximalFile();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasSemantics anotherInstance = Xmlization.Deserialize.deserializeIHasSemantics(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasSemanticsFromFile

        @Test
        public void testRoundTripIHasSemanticsFromMultiLanguageProperty() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final MultiLanguageProperty instance = CommonJsonization.loadMaximalMultiLanguageProperty();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasSemantics anotherInstance = Xmlization.Deserialize.deserializeIHasSemantics(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasSemanticsFromMultiLanguageProperty

        @Test
        public void testRoundTripIHasSemanticsFromOperation() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Operation instance = CommonJsonization.loadMaximalOperation();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasSemantics anotherInstance = Xmlization.Deserialize.deserializeIHasSemantics(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasSemanticsFromOperation

        @Test
        public void testRoundTripIHasSemanticsFromProperty() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Property instance = CommonJsonization.loadMaximalProperty();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasSemantics anotherInstance = Xmlization.Deserialize.deserializeIHasSemantics(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasSemanticsFromProperty

        @Test
        public void testRoundTripIHasSemanticsFromRange() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Range instance = CommonJsonization.loadMaximalRange();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasSemantics anotherInstance = Xmlization.Deserialize.deserializeIHasSemantics(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasSemanticsFromRange

        @Test
        public void testRoundTripIHasSemanticsFromReferenceElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final ReferenceElement instance = CommonJsonization.loadMaximalReferenceElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasSemantics anotherInstance = Xmlization.Deserialize.deserializeIHasSemantics(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasSemanticsFromReferenceElement

        @Test
        public void testRoundTripIHasSemanticsFromSubmodel() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Submodel instance = CommonJsonization.loadMaximalSubmodel();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasSemantics anotherInstance = Xmlization.Deserialize.deserializeIHasSemantics(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasSemanticsFromSubmodel

        @Test
        public void testRoundTripIHasSemanticsFromSubmodelElementCollection() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final SubmodelElementCollection instance = CommonJsonization.loadMaximalSubmodelElementCollection();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasSemantics anotherInstance = Xmlization.Deserialize.deserializeIHasSemantics(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasSemanticsFromSubmodelElementCollection

        @Test
        public void testRoundTripIHasSemanticsFromSubmodelElementList() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final SubmodelElementList instance = CommonJsonization.loadMaximalSubmodelElementList();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasSemantics anotherInstance = Xmlization.Deserialize.deserializeIHasSemantics(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasSemanticsFromSubmodelElementList

        @Test
        public void testRoundTripIHasExtensionsFromRelationshipElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final RelationshipElement instance = CommonJsonization.loadMaximalRelationshipElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasExtensions anotherInstance = Xmlization.Deserialize.deserializeIHasExtensions(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasExtensionsFromRelationshipElement

        @Test
        public void testRoundTripIHasExtensionsFromAnnotatedRelationshipElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final AnnotatedRelationshipElement instance = CommonJsonization.loadMaximalAnnotatedRelationshipElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasExtensions anotherInstance = Xmlization.Deserialize.deserializeIHasExtensions(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasExtensionsFromAnnotatedRelationshipElement

        @Test
        public void testRoundTripIHasExtensionsFromAssetAdministrationShell() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final AssetAdministrationShell instance = CommonJsonization.loadMaximalAssetAdministrationShell();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasExtensions anotherInstance = Xmlization.Deserialize.deserializeIHasExtensions(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasExtensionsFromAssetAdministrationShell

        @Test
        public void testRoundTripIHasExtensionsFromBasicEventElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final BasicEventElement instance = CommonJsonization.loadMaximalBasicEventElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasExtensions anotherInstance = Xmlization.Deserialize.deserializeIHasExtensions(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasExtensionsFromBasicEventElement

        @Test
        public void testRoundTripIHasExtensionsFromBlob() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Blob instance = CommonJsonization.loadMaximalBlob();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasExtensions anotherInstance = Xmlization.Deserialize.deserializeIHasExtensions(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasExtensionsFromBlob

        @Test
        public void testRoundTripIHasExtensionsFromCapability() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Capability instance = CommonJsonization.loadMaximalCapability();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasExtensions anotherInstance = Xmlization.Deserialize.deserializeIHasExtensions(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasExtensionsFromCapability

        @Test
        public void testRoundTripIHasExtensionsFromConceptDescription() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final ConceptDescription instance = CommonJsonization.loadMaximalConceptDescription();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasExtensions anotherInstance = Xmlization.Deserialize.deserializeIHasExtensions(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasExtensionsFromConceptDescription

        @Test
        public void testRoundTripIHasExtensionsFromEntity() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Entity instance = CommonJsonization.loadMaximalEntity();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasExtensions anotherInstance = Xmlization.Deserialize.deserializeIHasExtensions(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasExtensionsFromEntity

        @Test
        public void testRoundTripIHasExtensionsFromFile() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final File instance = CommonJsonization.loadMaximalFile();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasExtensions anotherInstance = Xmlization.Deserialize.deserializeIHasExtensions(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasExtensionsFromFile

        @Test
        public void testRoundTripIHasExtensionsFromMultiLanguageProperty() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final MultiLanguageProperty instance = CommonJsonization.loadMaximalMultiLanguageProperty();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasExtensions anotherInstance = Xmlization.Deserialize.deserializeIHasExtensions(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasExtensionsFromMultiLanguageProperty

        @Test
        public void testRoundTripIHasExtensionsFromOperation() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Operation instance = CommonJsonization.loadMaximalOperation();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasExtensions anotherInstance = Xmlization.Deserialize.deserializeIHasExtensions(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasExtensionsFromOperation

        @Test
        public void testRoundTripIHasExtensionsFromProperty() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Property instance = CommonJsonization.loadMaximalProperty();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasExtensions anotherInstance = Xmlization.Deserialize.deserializeIHasExtensions(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasExtensionsFromProperty

        @Test
        public void testRoundTripIHasExtensionsFromRange() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Range instance = CommonJsonization.loadMaximalRange();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasExtensions anotherInstance = Xmlization.Deserialize.deserializeIHasExtensions(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasExtensionsFromRange

        @Test
        public void testRoundTripIHasExtensionsFromReferenceElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final ReferenceElement instance = CommonJsonization.loadMaximalReferenceElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasExtensions anotherInstance = Xmlization.Deserialize.deserializeIHasExtensions(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasExtensionsFromReferenceElement

        @Test
        public void testRoundTripIHasExtensionsFromSubmodel() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Submodel instance = CommonJsonization.loadMaximalSubmodel();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasExtensions anotherInstance = Xmlization.Deserialize.deserializeIHasExtensions(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasExtensionsFromSubmodel

        @Test
        public void testRoundTripIHasExtensionsFromSubmodelElementCollection() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final SubmodelElementCollection instance = CommonJsonization.loadMaximalSubmodelElementCollection();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasExtensions anotherInstance = Xmlization.Deserialize.deserializeIHasExtensions(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasExtensionsFromSubmodelElementCollection

        @Test
        public void testRoundTripIHasExtensionsFromSubmodelElementList() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final SubmodelElementList instance = CommonJsonization.loadMaximalSubmodelElementList();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasExtensions anotherInstance = Xmlization.Deserialize.deserializeIHasExtensions(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasExtensionsFromSubmodelElementList

        @Test
        public void testRoundTripIReferableFromRelationshipElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final RelationshipElement instance = CommonJsonization.loadMaximalRelationshipElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IReferable anotherInstance = Xmlization.Deserialize.deserializeIReferable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIReferableFromRelationshipElement

        @Test
        public void testRoundTripIReferableFromAnnotatedRelationshipElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final AnnotatedRelationshipElement instance = CommonJsonization.loadMaximalAnnotatedRelationshipElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IReferable anotherInstance = Xmlization.Deserialize.deserializeIReferable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIReferableFromAnnotatedRelationshipElement

        @Test
        public void testRoundTripIReferableFromAssetAdministrationShell() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final AssetAdministrationShell instance = CommonJsonization.loadMaximalAssetAdministrationShell();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IReferable anotherInstance = Xmlization.Deserialize.deserializeIReferable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIReferableFromAssetAdministrationShell

        @Test
        public void testRoundTripIReferableFromBasicEventElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final BasicEventElement instance = CommonJsonization.loadMaximalBasicEventElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IReferable anotherInstance = Xmlization.Deserialize.deserializeIReferable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIReferableFromBasicEventElement

        @Test
        public void testRoundTripIReferableFromBlob() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Blob instance = CommonJsonization.loadMaximalBlob();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IReferable anotherInstance = Xmlization.Deserialize.deserializeIReferable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIReferableFromBlob

        @Test
        public void testRoundTripIReferableFromCapability() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Capability instance = CommonJsonization.loadMaximalCapability();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IReferable anotherInstance = Xmlization.Deserialize.deserializeIReferable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIReferableFromCapability

        @Test
        public void testRoundTripIReferableFromConceptDescription() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final ConceptDescription instance = CommonJsonization.loadMaximalConceptDescription();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IReferable anotherInstance = Xmlization.Deserialize.deserializeIReferable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIReferableFromConceptDescription

        @Test
        public void testRoundTripIReferableFromEntity() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Entity instance = CommonJsonization.loadMaximalEntity();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IReferable anotherInstance = Xmlization.Deserialize.deserializeIReferable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIReferableFromEntity

        @Test
        public void testRoundTripIReferableFromFile() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final File instance = CommonJsonization.loadMaximalFile();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IReferable anotherInstance = Xmlization.Deserialize.deserializeIReferable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIReferableFromFile

        @Test
        public void testRoundTripIReferableFromMultiLanguageProperty() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final MultiLanguageProperty instance = CommonJsonization.loadMaximalMultiLanguageProperty();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IReferable anotherInstance = Xmlization.Deserialize.deserializeIReferable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIReferableFromMultiLanguageProperty

        @Test
        public void testRoundTripIReferableFromOperation() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Operation instance = CommonJsonization.loadMaximalOperation();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IReferable anotherInstance = Xmlization.Deserialize.deserializeIReferable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIReferableFromOperation

        @Test
        public void testRoundTripIReferableFromProperty() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Property instance = CommonJsonization.loadMaximalProperty();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IReferable anotherInstance = Xmlization.Deserialize.deserializeIReferable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIReferableFromProperty

        @Test
        public void testRoundTripIReferableFromRange() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Range instance = CommonJsonization.loadMaximalRange();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IReferable anotherInstance = Xmlization.Deserialize.deserializeIReferable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIReferableFromRange

        @Test
        public void testRoundTripIReferableFromReferenceElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final ReferenceElement instance = CommonJsonization.loadMaximalReferenceElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IReferable anotherInstance = Xmlization.Deserialize.deserializeIReferable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIReferableFromReferenceElement

        @Test
        public void testRoundTripIReferableFromSubmodel() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Submodel instance = CommonJsonization.loadMaximalSubmodel();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IReferable anotherInstance = Xmlization.Deserialize.deserializeIReferable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIReferableFromSubmodel

        @Test
        public void testRoundTripIReferableFromSubmodelElementCollection() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final SubmodelElementCollection instance = CommonJsonization.loadMaximalSubmodelElementCollection();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IReferable anotherInstance = Xmlization.Deserialize.deserializeIReferable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIReferableFromSubmodelElementCollection

        @Test
        public void testRoundTripIReferableFromSubmodelElementList() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final SubmodelElementList instance = CommonJsonization.loadMaximalSubmodelElementList();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IReferable anotherInstance = Xmlization.Deserialize.deserializeIReferable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIReferableFromSubmodelElementList

        @Test
        public void testRoundTripIIdentifiableFromAssetAdministrationShell() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final AssetAdministrationShell instance = CommonJsonization.loadMaximalAssetAdministrationShell();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IIdentifiable anotherInstance = Xmlization.Deserialize.deserializeIIdentifiable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIIdentifiableFromAssetAdministrationShell

        @Test
        public void testRoundTripIIdentifiableFromConceptDescription() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final ConceptDescription instance = CommonJsonization.loadMaximalConceptDescription();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IIdentifiable anotherInstance = Xmlization.Deserialize.deserializeIIdentifiable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIIdentifiableFromConceptDescription

        @Test
        public void testRoundTripIIdentifiableFromSubmodel() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Submodel instance = CommonJsonization.loadMaximalSubmodel();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IIdentifiable anotherInstance = Xmlization.Deserialize.deserializeIIdentifiable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIIdentifiableFromSubmodel

        @Test
        public void testRoundTripIHasKindFromSubmodel() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Submodel instance = CommonJsonization.loadMaximalSubmodel();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasKind anotherInstance = Xmlization.Deserialize.deserializeIHasKind(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasKindFromSubmodel

        @Test
        public void testRoundTripIHasDataSpecificationFromRelationshipElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final RelationshipElement instance = CommonJsonization.loadMaximalRelationshipElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasDataSpecification anotherInstance = Xmlization.Deserialize.deserializeIHasDataSpecification(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasDataSpecificationFromRelationshipElement

        @Test
        public void testRoundTripIHasDataSpecificationFromAnnotatedRelationshipElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final AnnotatedRelationshipElement instance = CommonJsonization.loadMaximalAnnotatedRelationshipElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasDataSpecification anotherInstance = Xmlization.Deserialize.deserializeIHasDataSpecification(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasDataSpecificationFromAnnotatedRelationshipElement

        @Test
        public void testRoundTripIHasDataSpecificationFromAssetAdministrationShell() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final AssetAdministrationShell instance = CommonJsonization.loadMaximalAssetAdministrationShell();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasDataSpecification anotherInstance = Xmlization.Deserialize.deserializeIHasDataSpecification(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasDataSpecificationFromAssetAdministrationShell

        @Test
        public void testRoundTripIHasDataSpecificationFromBasicEventElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final BasicEventElement instance = CommonJsonization.loadMaximalBasicEventElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasDataSpecification anotherInstance = Xmlization.Deserialize.deserializeIHasDataSpecification(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasDataSpecificationFromBasicEventElement

        @Test
        public void testRoundTripIHasDataSpecificationFromBlob() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Blob instance = CommonJsonization.loadMaximalBlob();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasDataSpecification anotherInstance = Xmlization.Deserialize.deserializeIHasDataSpecification(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasDataSpecificationFromBlob

        @Test
        public void testRoundTripIHasDataSpecificationFromCapability() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Capability instance = CommonJsonization.loadMaximalCapability();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasDataSpecification anotherInstance = Xmlization.Deserialize.deserializeIHasDataSpecification(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasDataSpecificationFromCapability

        @Test
        public void testRoundTripIHasDataSpecificationFromConceptDescription() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final ConceptDescription instance = CommonJsonization.loadMaximalConceptDescription();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasDataSpecification anotherInstance = Xmlization.Deserialize.deserializeIHasDataSpecification(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasDataSpecificationFromConceptDescription

        @Test
        public void testRoundTripIHasDataSpecificationFromEntity() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Entity instance = CommonJsonization.loadMaximalEntity();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasDataSpecification anotherInstance = Xmlization.Deserialize.deserializeIHasDataSpecification(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasDataSpecificationFromEntity

        @Test
        public void testRoundTripIHasDataSpecificationFromFile() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final File instance = CommonJsonization.loadMaximalFile();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasDataSpecification anotherInstance = Xmlization.Deserialize.deserializeIHasDataSpecification(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasDataSpecificationFromFile

        @Test
        public void testRoundTripIHasDataSpecificationFromMultiLanguageProperty() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final MultiLanguageProperty instance = CommonJsonization.loadMaximalMultiLanguageProperty();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasDataSpecification anotherInstance = Xmlization.Deserialize.deserializeIHasDataSpecification(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasDataSpecificationFromMultiLanguageProperty

        @Test
        public void testRoundTripIHasDataSpecificationFromOperation() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Operation instance = CommonJsonization.loadMaximalOperation();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasDataSpecification anotherInstance = Xmlization.Deserialize.deserializeIHasDataSpecification(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasDataSpecificationFromOperation

        @Test
        public void testRoundTripIHasDataSpecificationFromProperty() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Property instance = CommonJsonization.loadMaximalProperty();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasDataSpecification anotherInstance = Xmlization.Deserialize.deserializeIHasDataSpecification(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasDataSpecificationFromProperty

        @Test
        public void testRoundTripIHasDataSpecificationFromRange() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Range instance = CommonJsonization.loadMaximalRange();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasDataSpecification anotherInstance = Xmlization.Deserialize.deserializeIHasDataSpecification(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasDataSpecificationFromRange

        @Test
        public void testRoundTripIHasDataSpecificationFromReferenceElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final ReferenceElement instance = CommonJsonization.loadMaximalReferenceElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasDataSpecification anotherInstance = Xmlization.Deserialize.deserializeIHasDataSpecification(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasDataSpecificationFromReferenceElement

        @Test
        public void testRoundTripIHasDataSpecificationFromSubmodel() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Submodel instance = CommonJsonization.loadMaximalSubmodel();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasDataSpecification anotherInstance = Xmlization.Deserialize.deserializeIHasDataSpecification(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasDataSpecificationFromSubmodel

        @Test
        public void testRoundTripIHasDataSpecificationFromSubmodelElementCollection() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final SubmodelElementCollection instance = CommonJsonization.loadMaximalSubmodelElementCollection();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasDataSpecification anotherInstance = Xmlization.Deserialize.deserializeIHasDataSpecification(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasDataSpecificationFromSubmodelElementCollection

        @Test
        public void testRoundTripIHasDataSpecificationFromSubmodelElementList() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final SubmodelElementList instance = CommonJsonization.loadMaximalSubmodelElementList();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IHasDataSpecification anotherInstance = Xmlization.Deserialize.deserializeIHasDataSpecification(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIHasDataSpecificationFromSubmodelElementList

        @Test
        public void testRoundTripIQualifiableFromRelationshipElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final RelationshipElement instance = CommonJsonization.loadMaximalRelationshipElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IQualifiable anotherInstance = Xmlization.Deserialize.deserializeIQualifiable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIQualifiableFromRelationshipElement

        @Test
        public void testRoundTripIQualifiableFromAnnotatedRelationshipElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final AnnotatedRelationshipElement instance = CommonJsonization.loadMaximalAnnotatedRelationshipElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IQualifiable anotherInstance = Xmlization.Deserialize.deserializeIQualifiable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIQualifiableFromAnnotatedRelationshipElement

        @Test
        public void testRoundTripIQualifiableFromBasicEventElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final BasicEventElement instance = CommonJsonization.loadMaximalBasicEventElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IQualifiable anotherInstance = Xmlization.Deserialize.deserializeIQualifiable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIQualifiableFromBasicEventElement

        @Test
        public void testRoundTripIQualifiableFromBlob() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Blob instance = CommonJsonization.loadMaximalBlob();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IQualifiable anotherInstance = Xmlization.Deserialize.deserializeIQualifiable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIQualifiableFromBlob

        @Test
        public void testRoundTripIQualifiableFromCapability() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Capability instance = CommonJsonization.loadMaximalCapability();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IQualifiable anotherInstance = Xmlization.Deserialize.deserializeIQualifiable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIQualifiableFromCapability

        @Test
        public void testRoundTripIQualifiableFromEntity() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Entity instance = CommonJsonization.loadMaximalEntity();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IQualifiable anotherInstance = Xmlization.Deserialize.deserializeIQualifiable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIQualifiableFromEntity

        @Test
        public void testRoundTripIQualifiableFromFile() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final File instance = CommonJsonization.loadMaximalFile();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IQualifiable anotherInstance = Xmlization.Deserialize.deserializeIQualifiable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIQualifiableFromFile

        @Test
        public void testRoundTripIQualifiableFromMultiLanguageProperty() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final MultiLanguageProperty instance = CommonJsonization.loadMaximalMultiLanguageProperty();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IQualifiable anotherInstance = Xmlization.Deserialize.deserializeIQualifiable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIQualifiableFromMultiLanguageProperty

        @Test
        public void testRoundTripIQualifiableFromOperation() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Operation instance = CommonJsonization.loadMaximalOperation();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IQualifiable anotherInstance = Xmlization.Deserialize.deserializeIQualifiable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIQualifiableFromOperation

        @Test
        public void testRoundTripIQualifiableFromProperty() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Property instance = CommonJsonization.loadMaximalProperty();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IQualifiable anotherInstance = Xmlization.Deserialize.deserializeIQualifiable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIQualifiableFromProperty

        @Test
        public void testRoundTripIQualifiableFromRange() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Range instance = CommonJsonization.loadMaximalRange();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IQualifiable anotherInstance = Xmlization.Deserialize.deserializeIQualifiable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIQualifiableFromRange

        @Test
        public void testRoundTripIQualifiableFromReferenceElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final ReferenceElement instance = CommonJsonization.loadMaximalReferenceElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IQualifiable anotherInstance = Xmlization.Deserialize.deserializeIQualifiable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIQualifiableFromReferenceElement

        @Test
        public void testRoundTripIQualifiableFromSubmodel() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Submodel instance = CommonJsonization.loadMaximalSubmodel();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IQualifiable anotherInstance = Xmlization.Deserialize.deserializeIQualifiable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIQualifiableFromSubmodel

        @Test
        public void testRoundTripIQualifiableFromSubmodelElementCollection() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final SubmodelElementCollection instance = CommonJsonization.loadMaximalSubmodelElementCollection();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IQualifiable anotherInstance = Xmlization.Deserialize.deserializeIQualifiable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIQualifiableFromSubmodelElementCollection

        @Test
        public void testRoundTripIQualifiableFromSubmodelElementList() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final SubmodelElementList instance = CommonJsonization.loadMaximalSubmodelElementList();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IQualifiable anotherInstance = Xmlization.Deserialize.deserializeIQualifiable(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIQualifiableFromSubmodelElementList

        @Test
        public void testRoundTripISubmodelElementFromRelationshipElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final RelationshipElement instance = CommonJsonization.loadMaximalRelationshipElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final ISubmodelElement anotherInstance = Xmlization.Deserialize.deserializeISubmodelElement(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripISubmodelElementFromRelationshipElement

        @Test
        public void testRoundTripISubmodelElementFromAnnotatedRelationshipElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final AnnotatedRelationshipElement instance = CommonJsonization.loadMaximalAnnotatedRelationshipElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final ISubmodelElement anotherInstance = Xmlization.Deserialize.deserializeISubmodelElement(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripISubmodelElementFromAnnotatedRelationshipElement

        @Test
        public void testRoundTripISubmodelElementFromBasicEventElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final BasicEventElement instance = CommonJsonization.loadMaximalBasicEventElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final ISubmodelElement anotherInstance = Xmlization.Deserialize.deserializeISubmodelElement(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripISubmodelElementFromBasicEventElement

        @Test
        public void testRoundTripISubmodelElementFromBlob() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Blob instance = CommonJsonization.loadMaximalBlob();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final ISubmodelElement anotherInstance = Xmlization.Deserialize.deserializeISubmodelElement(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripISubmodelElementFromBlob

        @Test
        public void testRoundTripISubmodelElementFromCapability() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Capability instance = CommonJsonization.loadMaximalCapability();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final ISubmodelElement anotherInstance = Xmlization.Deserialize.deserializeISubmodelElement(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripISubmodelElementFromCapability

        @Test
        public void testRoundTripISubmodelElementFromEntity() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Entity instance = CommonJsonization.loadMaximalEntity();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final ISubmodelElement anotherInstance = Xmlization.Deserialize.deserializeISubmodelElement(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripISubmodelElementFromEntity

        @Test
        public void testRoundTripISubmodelElementFromFile() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final File instance = CommonJsonization.loadMaximalFile();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final ISubmodelElement anotherInstance = Xmlization.Deserialize.deserializeISubmodelElement(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripISubmodelElementFromFile

        @Test
        public void testRoundTripISubmodelElementFromMultiLanguageProperty() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final MultiLanguageProperty instance = CommonJsonization.loadMaximalMultiLanguageProperty();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final ISubmodelElement anotherInstance = Xmlization.Deserialize.deserializeISubmodelElement(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripISubmodelElementFromMultiLanguageProperty

        @Test
        public void testRoundTripISubmodelElementFromOperation() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Operation instance = CommonJsonization.loadMaximalOperation();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final ISubmodelElement anotherInstance = Xmlization.Deserialize.deserializeISubmodelElement(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripISubmodelElementFromOperation

        @Test
        public void testRoundTripISubmodelElementFromProperty() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Property instance = CommonJsonization.loadMaximalProperty();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final ISubmodelElement anotherInstance = Xmlization.Deserialize.deserializeISubmodelElement(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripISubmodelElementFromProperty

        @Test
        public void testRoundTripISubmodelElementFromRange() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Range instance = CommonJsonization.loadMaximalRange();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final ISubmodelElement anotherInstance = Xmlization.Deserialize.deserializeISubmodelElement(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripISubmodelElementFromRange

        @Test
        public void testRoundTripISubmodelElementFromReferenceElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final ReferenceElement instance = CommonJsonization.loadMaximalReferenceElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final ISubmodelElement anotherInstance = Xmlization.Deserialize.deserializeISubmodelElement(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripISubmodelElementFromReferenceElement

        @Test
        public void testRoundTripISubmodelElementFromSubmodelElementCollection() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final SubmodelElementCollection instance = CommonJsonization.loadMaximalSubmodelElementCollection();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final ISubmodelElement anotherInstance = Xmlization.Deserialize.deserializeISubmodelElement(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripISubmodelElementFromSubmodelElementCollection

        @Test
        public void testRoundTripISubmodelElementFromSubmodelElementList() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final SubmodelElementList instance = CommonJsonization.loadMaximalSubmodelElementList();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final ISubmodelElement anotherInstance = Xmlization.Deserialize.deserializeISubmodelElement(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripISubmodelElementFromSubmodelElementList

        @Test
        public void testRoundTripIRelationshipElementFromAnnotatedRelationshipElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final AnnotatedRelationshipElement instance = CommonJsonization.loadMaximalAnnotatedRelationshipElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IRelationshipElement anotherInstance = Xmlization.Deserialize.deserializeIRelationshipElement(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIRelationshipElementFromAnnotatedRelationshipElement

        @Test
        public void testRoundTripIRelationshipElementFromRelationshipElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final RelationshipElement instance = CommonJsonization.loadMaximalRelationshipElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IRelationshipElement anotherInstance = Xmlization.Deserialize.deserializeIRelationshipElement(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIRelationshipElementFromRelationshipElement

        @Test
        public void testRoundTripIDataElementFromBlob() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Blob instance = CommonJsonization.loadMaximalBlob();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IDataElement anotherInstance = Xmlization.Deserialize.deserializeIDataElement(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIDataElementFromBlob

        @Test
        public void testRoundTripIDataElementFromFile() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final File instance = CommonJsonization.loadMaximalFile();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IDataElement anotherInstance = Xmlization.Deserialize.deserializeIDataElement(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIDataElementFromFile

        @Test
        public void testRoundTripIDataElementFromMultiLanguageProperty() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final MultiLanguageProperty instance = CommonJsonization.loadMaximalMultiLanguageProperty();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IDataElement anotherInstance = Xmlization.Deserialize.deserializeIDataElement(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIDataElementFromMultiLanguageProperty

        @Test
        public void testRoundTripIDataElementFromProperty() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Property instance = CommonJsonization.loadMaximalProperty();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IDataElement anotherInstance = Xmlization.Deserialize.deserializeIDataElement(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIDataElementFromProperty

        @Test
        public void testRoundTripIDataElementFromRange() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final Range instance = CommonJsonization.loadMaximalRange();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IDataElement anotherInstance = Xmlization.Deserialize.deserializeIDataElement(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIDataElementFromRange

        @Test
        public void testRoundTripIDataElementFromReferenceElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final ReferenceElement instance = CommonJsonization.loadMaximalReferenceElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IDataElement anotherInstance = Xmlization.Deserialize.deserializeIDataElement(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIDataElementFromReferenceElement

        @Test
        public void testRoundTripIEventElementFromBasicEventElement() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final BasicEventElement instance = CommonJsonization.loadMaximalBasicEventElement();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IEventElement anotherInstance = Xmlization.Deserialize.deserializeIEventElement(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIEventElementFromBasicEventElement

        @Test
        public void testRoundTripIDataSpecificationContentFromDataSpecificationIec61360() throws IOException, XMLStreamException {
          // We load from JSON here just to jump-start the round trip.
          // The round-trip goes then over XML.
          final DataSpecificationIec61360 instance = CommonJsonization.loadMaximalDataSpecificationIec61360();
          final StringWriter stringOut = new StringWriter();
          final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();
          final XMLStreamWriter xmlWriter = outputFactory.createXMLStreamWriter(stringOut);
  
          Xmlization.Serialize.to(instance, xmlWriter);
          // De-serialize from XML
          final String outputText = stringOut.toString();
          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
          final XMLEventReader xmlReader = xmlInputFactory.createXMLEventReader(new StringReader(outputText));
          final IDataSpecificationContent anotherInstance = Xmlization.Deserialize.deserializeIDataSpecificationContent(xmlReader);
          // Serialize back to XML
          final StringWriter anotherStringOut = new StringWriter();
          final XMLStreamWriter anotherXmlWriter = outputFactory.createXMLStreamWriter(anotherStringOut);
  
          Xmlization.Serialize.to(anotherInstance, anotherXmlWriter);
          assertEquals(outputText, anotherStringOut.toString());
        }  // void testRoundTripIDataSpecificationContentFromDataSpecificationIec61360
}  // class TestXmlizationOfInterfaces

/*
 * This code has been automatically generated by testgen.
 * Do NOT edit or append.
 */
